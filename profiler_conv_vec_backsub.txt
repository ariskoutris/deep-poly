not verified
Wrote profile results to verifier.py.lprof
Timer unit: 1e-06 s

Total time: 0.079563 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: compute_weight_matrix at line 144

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   144                                               @profile
   145                                               def compute_weight_matrix(self, inp_shape):
   146                                                   
   147         2          0.0      0.0      0.0          @profile
   148         2        103.0     51.5      0.1          def get_weight(inp_shape, conv_row, conv_col, kernel, vectorized=True):
   149                                                       temp = torch.zeros(inp_shape)
   150                                                       if vectorized:
   151                                                           end_row = conv_row + kernel.shape[1]
   152                                                           end_col = conv_col + kernel.shape[2]
   153                                                           temp[:, conv_row:end_row, conv_col:end_col] = kernel
   154                                                       else:
   155                                                           for c in range(kernel.shape[0]):
   156                                                               for i in range(kernel.shape[1]):
   157                                                                   for j in range(kernel.shape[2]):
   158                                                                       temp[c][conv_row + i][conv_col + j] = kernel[c][i][j]
   159                                           
   160                                                       return temp
   161                                           
   162                                                   
   163         2          2.0      1.0      0.0          @profile
   164         2         91.0     45.5      0.1          def get_weight_matrix(conv, inp_shape):
   165                                                       kernel = conv.weight.data.detach()
   166                                                       C_out, C_in, K_h, K_w = kernel.shape
   167                                                       N_in, C_in, H_i, W_i = inp_shape
   168                                                       H_o = ((inp_shape[-2] + conv.padding[-2] + conv.padding[-2] - conv.kernel_size[-2]) // conv.stride[-2] + 1)
   169                                                       W_o = ((inp_shape[-1] + conv.padding[-1] + conv.padding[-1] - conv.kernel_size[-1]) // conv.stride[-1] + 1)
   170                                                       out_shape = N_in, C_out, H_o, W_o
   171                                           
   172                                                       H_grd, W_grd = H_o, H_i
   173                                                       H_blk, W_blk = W_o, W_i
   174                                           
   175                                                       W_conv = torch.zeros((C_out, H_grd, H_blk, C_in, W_grd, W_blk), dtype=torch.double)
   176                                           
   177                                                       for c in range(C_out):
   178                                                           for i in range(H_o):
   179                                                               for j in range(W_o):
   180                                                                   padded_H_i, padded_W_i = H_i + 2 * conv.padding[0], W_i + 2 * conv.padding[1]
   181                                                                   conv_row, conv_col = i * conv.stride[0], j * conv.stride[1]
   182                                                                   if conv_row >= padded_H_i | conv_col >= padded_W_i:
   183                                                                       continue
   184                                                                   temp_weight = get_weight((C_in, padded_H_i, padded_W_i), conv_row, conv_col, kernel[c])
   185                                                                   W_conv[c, i, j] = temp_weight[:, conv.padding[0] : H_i+conv.padding[0], conv.padding[1] : W_i + conv.padding[1]]
   186                                           
   187                                                       B_conv = conv.bias.data.detach()
   188                                                       B_conv = torch.ones(H_o*W_o, C_out) * B_conv
   189                                                       B_conv = B_conv.t()
   190                                           
   191                                                       return W_conv, B_conv, out_shape
   192                                                   
   193                                                   # conv = nn.Conv2d(1, 16, kernel_size=(3,3), padding=(2, 2), stride=(2, 2))
   194                                                   # conv.double()
   195                                                   # # conv.bias.data = torch.zeros_like(conv.bias)
   196                                                   # inp_shape = (1, 1, 28, 28)
   197                                           
   198         2      79307.0  39653.5     99.7          W, B, out_shape = get_weight_matrix(self.layer, inp_shape)
   199                                           
   200         2         26.0     13.0      0.0          W = torch.flatten(W, start_dim=0, end_dim=2)
   201         2          5.0      2.5      0.0          W = torch.flatten(W, start_dim=1, end_dim=3)
   202                                           
   203         2         28.0     14.0      0.0          B = B.flatten()
   204         2          1.0      0.5      0.0          W.shape[1] == B.shape[0]
   205                                           
   206                                                   # def test_weight(T, B, conv, inp_shape):
   207                                                   #     i = torch.randn(*inp_shape, dtype = torch.double)
   208                                                   #     out = i.flatten() @ T.t() + B
   209                                                   #     print(torch.allclose(conv(i).flatten(), out.flatten(), atol=1e-06))
   210                                           
   211                                                   # for i in range(100):
   212                                                   #     test_weight(W, B, conv, inp_shape)
   213         2          0.0      0.0      0.0          return W, B, out_shape

Total time: 0.008545 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: get_weight at line 147

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   147                                                   @profile
   148                                                   def get_weight(inp_shape, conv_row, conv_col, kernel, vectorized=True):
   149      1568       2066.0      1.3     24.2              temp = torch.zeros(inp_shape)
   150      1568        153.0      0.1      1.8              if vectorized:
   151      1568        344.0      0.2      4.0                  end_row = conv_row + kernel.shape[1]
   152      1568        294.0      0.2      3.4                  end_col = conv_col + kernel.shape[2]
   153      1568       5471.0      3.5     64.0                  temp[:, conv_row:end_row, conv_col:end_col] = kernel
   154                                                       else:
   155                                                           for c in range(kernel.shape[0]):
   156                                                               for i in range(kernel.shape[1]):
   157                                                                   for j in range(kernel.shape[2]):
   158                                                                       temp[c][conv_row + i][conv_col + j] = kernel[c][i][j]
   159                                           
   160      1568        217.0      0.1      2.5              return temp

Total time: 0.029564 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: get_weight_matrix at line 163

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   163                                                   @profile
   164                                                   def get_weight_matrix(conv, inp_shape):
   165         1         10.0     10.0      0.0              kernel = conv.weight.data.detach()
   166         1          1.0      1.0      0.0              C_out, C_in, K_h, K_w = kernel.shape
   167         1          0.0      0.0      0.0              N_in, C_in, H_i, W_i = inp_shape
   168         1          1.0      1.0      0.0              H_o = ((inp_shape[-2] + conv.padding[-2] + conv.padding[-2] - conv.kernel_size[-2]) // conv.stride[-2] + 1)
   169         1          1.0      1.0      0.0              W_o = ((inp_shape[-1] + conv.padding[-1] + conv.padding[-1] - conv.kernel_size[-1]) // conv.stride[-1] + 1)
   170         1          0.0      0.0      0.0              out_shape = N_in, C_out, H_o, W_o
   171                                           
   172         1          0.0      0.0      0.0              H_grd, W_grd = H_o, H_i
   173         1          0.0      0.0      0.0              H_blk, W_blk = W_o, W_i
   174                                           
   175         1       3488.0   3488.0     11.8              W_conv = torch.zeros((C_out, H_grd, H_blk, C_in, W_grd, W_blk), dtype=torch.double)
   176                                           
   177        33         11.0      0.3      0.0              for c in range(C_out):
   178       256         27.0      0.1      0.1                  for i in range(H_o):
   179      1792        261.0      0.1      0.9                      for j in range(W_o):
   180      1568        454.0      0.3      1.5                          padded_H_i, padded_W_i = H_i + 2 * conv.padding[0], W_i + 2 * conv.padding[1]
   181      1568        387.0      0.2      1.3                          conv_row, conv_col = i * conv.stride[0], j * conv.stride[1]
   182      1568        264.0      0.2      0.9                          if conv_row >= padded_H_i | conv_col >= padded_W_i:
   183                                                                       continue
   184      1568      12977.0      8.3     43.9                          temp_weight = get_weight((C_in, padded_H_i, padded_W_i), conv_row, conv_col, kernel[c])
   185      1568      11646.0      7.4     39.4                          W_conv[c, i, j] = temp_weight[:, conv.padding[0] : H_i+conv.padding[0], conv.padding[1] : W_i + conv.padding[1]]
   186                                           
   187         1         10.0     10.0      0.0              B_conv = conv.bias.data.detach()
   188         1         21.0     21.0      0.1              B_conv = torch.ones(H_o*W_o, C_out) * B_conv
   189         1          5.0      5.0      0.0              B_conv = B_conv.t()
   190                                           
   191         1          0.0      0.0      0.0              return W_conv, B_conv, out_shape

Total time: 1.06496 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: compute_bound at line 215

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   215                                               @profile 
   216                                               def compute_bound(self, bounds: DpBounds):
   217        62        120.0      1.9      0.0          if self.inp_shape != None and self.inp_shape == bounds.shape:
   218        60         28.0      0.5      0.0              r = self.constraints.lr
   219        60         17.0      0.3      0.0              o = self.constraints.lo
   220                                                   else:
   221         2          4.0      2.0      0.0              self.inp_shape = bounds.shape
   222         2      79577.0  39788.5      7.5              r, o, out_shape = self.compute_weight_matrix(bounds.shape)
   223         2          9.0      4.5      0.0              self.constraints = DpConstraints(r, r, o, o)
   224         2          2.0      1.0      0.0              self.out_shape = out_shape
   225                                           
   226        62     984438.0  15878.0     92.4          self.bounds = bounds_mul_constraints(DpConstraints(r.t(), r.t(), o, o), bounds)
   227        62        633.0     10.2      0.1          self.bounds.lb = self.bounds.lb.view(self.out_shape)
   228        62        119.0      1.9      0.0          self.bounds.ub = self.bounds.ub.view(self.out_shape)
   229        62         11.0      0.2      0.0          return self.bounds

Total time: 31.3072 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: propagate_sample at line 284

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   284                                           @profile
   285                                           def propagate_sample(model, x, eps, le_layer=None, min_val=0, max_val=1, layers=None):
   286        31         25.0      0.8      0.0      time_start = perf_counter()
   287        31       1009.0     32.5      0.0      bounds = get_input_bounds(x, eps, min_val, max_val)
   288        31         43.0      1.4      0.0      input_layer = DpInput(bounds)
   289        31         12.0      0.4      0.0      dp_layers = [input_layer] if layers == None else layers
   290        31        760.0     24.5      0.0      log_layer_bounds(logger, input_layer, 'Input Layer')
   291       341        298.0      0.9      0.0      for i, layer in enumerate(model):
   292       310         53.0      0.2      0.0          dp_layer = None
   293       310         98.0      0.3      0.0          if layers != None:
   294       300         78.0      0.3      0.0              dp_layer = dp_layers[i + 1] # i + 1 as the first element is DpInput
   295       300    3885884.0  12952.9     12.4              dp_layer.compute_bound(dp_layers[i].bounds)
   296        10          8.0      0.8      0.0          elif isinstance(layer, nn.Flatten):
   297         1          2.0      2.0      0.0              dp_layer = DpFlatten(layer)
   298         1         34.0     34.0      0.0              dp_layer.compute_bound(dp_layers[i].bounds)
   299         9          1.0      0.1      0.0          elif isinstance(layer, nn.Linear):
   300         3         54.0     18.0      0.0              dp_layer = DpLinear(layer)
   301         3       1065.0    355.0      0.0              dp_layer.compute_bound(dp_layers[i].bounds)
   302         6          2.0      0.3      0.0          elif isinstance(layer, nn.ReLU):
   303         2          8.0      4.0      0.0              dp_layer = DpRelu(layer, False)
   304         2     101703.0  50851.5      0.3              dp_layer.compute_bound(dp_layers[i].bounds)
   305         4          2.0      0.5      0.0          elif isinstance(layer, nn.LeakyReLU):
   306         2          5.0      2.5      0.0              dp_layer = DpRelu(layer)
   307         2        522.0    261.0      0.0              dp_layer.compute_bound(dp_layers[i].bounds)
   308         2          0.0      0.0      0.0          elif isinstance(layer, nn.Conv2d):
   309         2          7.0      3.5      0.0              dp_layer = DpConv(layer)
   310         2     128187.0  64093.5      0.4              dp_layer.compute_bound(dp_layers[i].bounds)
   311                                           
   312                                                   #dp_layer.compute_bound(dp_layers[i].bounds)
   313       310        228.0      0.7      0.0          if layers == None:
   314        10          6.0      0.6      0.0              dp_layers.append(dp_layer)
   315                                                       
   316                                                   #TODO: Call backsub only before RELUs
   317       310        461.0      1.5      0.0          if not isinstance(layer, nn.Flatten):
   318       279       2822.0     10.1      0.0              if i + 2 <= len(model) and (isinstance(model[i + 1], nn.ReLU) or isinstance(model[i + 1], nn.LeakyReLU)):
   319       124   26409047.0 212976.2     84.4                  dp_layer.bounds = deeppoly_backsub(dp_layers[:i+2]) # i + 2 as the first element is DpInput
   320                                                   # if not isinstance(layer, nn.Flatten):
   321                                                   #     dp_layer.bounds = deeppoly_backsub(dp_layers[:i+2]) # i + 2 as the first element is DpInput
   322       310      11352.0     36.6      0.0          log_layer_bounds(logger, dp_layer, f'Layer {i + 1} [{layer}]')
   323        31       2692.0     86.8      0.0      logger.warning(f'Propagation Time: {perf_counter() - time_start:.4f}')
   324                                           
   325        31          7.0      0.2      0.0      if le_layer is not None:
   326        31          3.0      0.1      0.0          if layers is None:
   327         1          0.0      0.0      0.0              dp_layers.append(le_layer)
   328         1      25939.0  25939.0      0.1              le_layer.bounds = deeppoly_backsub(dp_layers)
   329                                                   else:
   330        30         82.0      2.7      0.0              dp_layers[-1] = le_layer
   331        30     734146.0  24471.5      2.3              le_layer.bounds = deeppoly_backsub(dp_layers)
   332        31        552.0     17.8      0.0          log_layer_bounds(logger, le_layer, f'Layer {len(dp_layers) - 1} [{le_layer}]:')
   333                                           
   334        31          5.0      0.2      0.0      return dp_layers

Total time: 51.6227 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: certify_sample at line 342

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   342                                           @profile
   343                                           def certify_sample(model, x, y, eps, use_le=True, use_slope_opt=True) -> bool:
   344         1        320.0    320.0      0.0      model.double()
   345         1          9.0      9.0      0.0      x.double()
   346                                           
   347         1          1.0      1.0      0.0      if x.dim() == 3:
   348         1          5.0      5.0      0.0          x = x.unsqueeze(0)
   349                                           
   350         1          1.0      1.0      0.0      if use_le:
   351         1         14.0     14.0      0.0          n_classes = model[-1].out_features
   352         1        320.0    320.0      0.0          le_layer = DiffLayer(y, n_classes)
   353         1    1123870.0    1e+06      2.2          dp_layers = propagate_sample(model, x, eps, le_layer=le_layer)
   354                                               else:
   355                                                   dp_layers = propagate_sample(model, x, eps)
   356                                           
   357         1          0.0      0.0      0.0      bounds = dp_layers[-1].bounds
   358                                           
   359         1         24.0     24.0      0.0      verified = check_postcondition_le(bounds) if use_le else check_postcondition(y, bounds)
   360         1          0.0      0.0      0.0      if verified:
   361                                                   logger.warning(f'Certification Distance: {bounds.get_certification_distance()}')
   362                                                   return True
   363                                               else:
   364         1   50498123.0    5e+07     97.8          verified = certify_with_alphas(model, dp_layers, x, y, eps, use_le) if use_slope_opt else False
   365                                           
   366         1          0.0      0.0      0.0      return verified

Total time: 50.4978 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: certify_with_alphas at line 368

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   368                                           @profile
   369                                           def certify_with_alphas(model, dp_layers, x, y, eps, use_le=True):
   370                                               
   371         1        189.0    189.0      0.0      alphas_dict = init_alphas(model, x.shape)
   372         1          0.0      0.0      0.0      if alphas_dict is None:
   373                                                   return False
   374         1          7.0      7.0      0.0      dp_layers = assign_alphas_to_relus(dp_layers, alphas_dict)
   375                                           
   376         1         52.0     52.0      0.0      loss_func = nn.CrossEntropyLoss() 
   377         1         52.0     52.0      0.0      optimizer = torch.optim.Adam([alphas_dict[key].value for key in alphas_dict], lr=2)
   378                                               
   379                                               #TODO: Add early stopping
   380        31         13.0      0.4      0.0      for _ in range(30):
   381                                                   
   382        30          5.0      0.2      0.0          if use_le:
   383        30        292.0      9.7      0.0              n_classes = model[-1].out_features
   384        30       2672.0     89.1      0.0              le_layer = DiffLayer(y, n_classes)
   385        30   30185552.0    1e+06     59.8              dp_layers = propagate_sample(model, x, eps, le_layer=le_layer, layers=dp_layers)
   386                                                   else:
   387                                                       dp_layers = propagate_sample(model, x, eps, layers=dp_layers)
   388                                                       
   389        30     138526.0   4617.5      0.3          bounds = dp_layers[-1].bounds
   390                                                   
   391        30         14.0      0.5      0.0          if use_le:
   392        30       8013.0    267.1      0.0              loss = torch.sum(-bounds.lb[bounds.lb < 0])
   393                                                   else:
   394                                                       loss = loss_func(bounds.get_loss_tensor(y), torch.tensor(y).view(1))
   395                                                   
   396        30       2099.0     70.0      0.0          optimizer.zero_grad()
   397        30   20150981.0 671699.4     39.9          loss.backward()
   398        30       7814.0    260.5      0.0          optimizer.step()
   399                                                   
   400       150         60.0      0.4      0.0          for alpha_param in alphas_dict.values():
   401       120        408.0      3.4      0.0              alpha_param.value.data.clamp_(alpha_param.lb, alpha_param.ub)
   402                                           
   403        30        963.0     32.1      0.0          verified = check_postcondition_le(bounds) if use_le else check_postcondition(y, bounds)
   404        30         79.0      2.6      0.0          if verified:
   405                                                       logger.warning(f'Certification Distance: {bounds.get_certification_distance()}\n')
   406                                                       return True
   407                                                   
   408         1          0.0      0.0      0.0      return False

