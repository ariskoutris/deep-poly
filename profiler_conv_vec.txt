not verified
Wrote profile results to verifier.py.lprof
Timer unit: 1e-06 s

Total time: 0.084392 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: compute_weight_matrix at line 143

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   143                                               @profile
   144                                               def compute_weight_matrix(self, inp_shape):
   145                                                   
   146         2          0.0      0.0      0.0          @profile
   147         2         60.0     30.0      0.1          def get_weight(inp_shape, conv_row, conv_col, kernel, vectorized=True):
   148                                                       temp = torch.zeros(inp_shape)
   149                                                       if vectorized:
   150                                                           end_row = conv_row + kernel.shape[1]
   151                                                           end_col = conv_col + kernel.shape[2]
   152                                                           temp[:, conv_row:end_row, conv_col:end_col] = kernel
   153                                                       else:
   154                                                           for c in range(kernel.shape[0]):
   155                                                               for i in range(kernel.shape[1]):
   156                                                                   for j in range(kernel.shape[2]):
   157                                                                       temp[c][conv_row + i][conv_col + j] = kernel[c][i][j]
   158                                           
   159                                                       return temp
   160                                           
   161                                                   
   162         2          0.0      0.0      0.0          @profile
   163         2         56.0     28.0      0.1          def get_weight_matrix(conv, inp_shape):
   164                                                       #TODO: Improve efficiency. Remove loops
   165                                                       kernel = conv.weight.data.detach()
   166                                                       C_out, C_in, K_h, K_w = kernel.shape
   167                                                       N_in, C_in, H_i, W_i = inp_shape
   168                                                       H_o = ((inp_shape[-2] + conv.padding[-2] + conv.padding[-2] - conv.kernel_size[-2]) // conv.stride[-2] + 1)
   169                                                       W_o = ((inp_shape[-1] + conv.padding[-1] + conv.padding[-1] - conv.kernel_size[-1]) // conv.stride[-1] + 1)
   170                                                       out_shape = N_in, C_out, H_o, W_o
   171                                           
   172                                                       H_grd, W_grd = H_o, H_i
   173                                                       H_blk, W_blk = W_o, W_i
   174                                           
   175                                                       W_conv = torch.zeros((C_out, H_grd, H_blk, C_in, W_grd, W_blk), dtype=torch.double)
   176                                           
   177                                                       for c in range(C_out):
   178                                                           for i in range(H_o):
   179                                                               for j in range(W_o):
   180                                                                   padded_H_i, padded_W_i = H_i + 2 * conv.padding[0], W_i + 2 * conv.padding[1]
   181                                                                   conv_row, conv_col = i * conv.stride[0], j * conv.stride[1]
   182                                                                   if conv_row >= padded_H_i | conv_col >= padded_W_i:
   183                                                                       continue
   184                                                                   temp_weight = get_weight((C_in, padded_H_i, padded_W_i), conv_row, conv_col, kernel[c])
   185                                                                   W_conv[c, i, j] = temp_weight[:, conv.padding[0] : H_i+conv.padding[0], conv.padding[1] : W_i + conv.padding[1]]
   186                                           
   187                                                       B_conv = conv.bias.data.detach()
   188                                                       B_conv = torch.ones(H_o*W_o, C_out) * B_conv
   189                                                       B_conv = B_conv.t()
   190                                           
   191                                                       return W_conv, B_conv, out_shape
   192                                                   
   193                                                   # conv = nn.Conv2d(1, 16, kernel_size=(3,3), padding=(2, 2), stride=(2, 2))
   194                                                   # conv.double()
   195                                                   # # conv.bias.data = torch.zeros_like(conv.bias)
   196                                                   # inp_shape = (1, 1, 28, 28)
   197                                           
   198         2      84213.0  42106.5     99.8          W, B, out_shape = get_weight_matrix(self.layer, inp_shape)
   199                                           
   200         2         29.0     14.5      0.0          W = torch.flatten(W, start_dim=0, end_dim=2)
   201         2          5.0      2.5      0.0          W = torch.flatten(W, start_dim=1, end_dim=3)
   202                                           
   203         2         27.0     13.5      0.0          B = B.flatten()
   204         2          2.0      1.0      0.0          W.shape[1] == B.shape[0]
   205                                           
   206                                                   # def test_weight(T, B, conv, inp_shape):
   207                                                   #     i = torch.randn(*inp_shape, dtype = torch.double)
   208                                                   #     out = i.flatten() @ T.t() + B
   209                                                   #     print(torch.allclose(conv(i).flatten(), out.flatten(), atol=1e-06))
   210                                           
   211                                                   # for i in range(100):
   212                                                   #     test_weight(W, B, conv, inp_shape)
   213         2          0.0      0.0      0.0          return W, B, out_shape

Total time: 0.008689 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: get_weight at line 146

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   146                                                   @profile
   147                                                   def get_weight(inp_shape, conv_row, conv_col, kernel, vectorized=True):
   148      1568       2162.0      1.4     24.9              temp = torch.zeros(inp_shape)
   149      1568        202.0      0.1      2.3              if vectorized:
   150      1568        336.0      0.2      3.9                  end_row = conv_row + kernel.shape[1]
   151      1568        346.0      0.2      4.0                  end_col = conv_col + kernel.shape[2]
   152      1568       5436.0      3.5     62.6                  temp[:, conv_row:end_row, conv_col:end_col] = kernel
   153                                                       else:
   154                                                           for c in range(kernel.shape[0]):
   155                                                               for i in range(kernel.shape[1]):
   156                                                                   for j in range(kernel.shape[2]):
   157                                                                       temp[c][conv_row + i][conv_col + j] = kernel[c][i][j]
   158                                           
   159      1568        207.0      0.1      2.4              return temp

Total time: 0.02987 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: get_weight_matrix at line 162

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   162                                                   @profile
   163                                                   def get_weight_matrix(conv, inp_shape):
   164                                                       #TODO: Improve efficiency. Remove loops
   165         1         11.0     11.0      0.0              kernel = conv.weight.data.detach()
   166         1          1.0      1.0      0.0              C_out, C_in, K_h, K_w = kernel.shape
   167         1          0.0      0.0      0.0              N_in, C_in, H_i, W_i = inp_shape
   168         1          2.0      2.0      0.0              H_o = ((inp_shape[-2] + conv.padding[-2] + conv.padding[-2] - conv.kernel_size[-2]) // conv.stride[-2] + 1)
   169         1          1.0      1.0      0.0              W_o = ((inp_shape[-1] + conv.padding[-1] + conv.padding[-1] - conv.kernel_size[-1]) // conv.stride[-1] + 1)
   170         1          0.0      0.0      0.0              out_shape = N_in, C_out, H_o, W_o
   171                                           
   172         1          0.0      0.0      0.0              H_grd, W_grd = H_o, H_i
   173         1          0.0      0.0      0.0              H_blk, W_blk = W_o, W_i
   174                                           
   175         1       3624.0   3624.0     12.1              W_conv = torch.zeros((C_out, H_grd, H_blk, C_in, W_grd, W_blk), dtype=torch.double)
   176                                           
   177        33         10.0      0.3      0.0              for c in range(C_out):
   178       256         42.0      0.2      0.1                  for i in range(H_o):
   179      1792        304.0      0.2      1.0                      for j in range(W_o):
   180      1568        499.0      0.3      1.7                          padded_H_i, padded_W_i = H_i + 2 * conv.padding[0], W_i + 2 * conv.padding[1]
   181      1568        389.0      0.2      1.3                          conv_row, conv_col = i * conv.stride[0], j * conv.stride[1]
   182      1568        290.0      0.2      1.0                          if conv_row >= padded_H_i | conv_col >= padded_W_i:
   183                                                                       continue
   184      1568      13166.0      8.4     44.1                          temp_weight = get_weight((C_in, padded_H_i, padded_W_i), conv_row, conv_col, kernel[c])
   185      1568      11485.0      7.3     38.4                          W_conv[c, i, j] = temp_weight[:, conv.padding[0] : H_i+conv.padding[0], conv.padding[1] : W_i + conv.padding[1]]
   186                                           
   187         1         17.0     17.0      0.1              B_conv = conv.bias.data.detach()
   188         1         24.0     24.0      0.1              B_conv = torch.ones(H_o*W_o, C_out) * B_conv
   189         1          5.0      5.0      0.0              B_conv = B_conv.t()
   190                                           
   191         1          0.0      0.0      0.0              return W_conv, B_conv, out_shape

Total time: 0.13667 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: compute_bound at line 215

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   215                                               @profile 
   216                                               def compute_bound(self, bounds: DpBounds):
   217         2          1.0      0.5      0.0          if self.inp_shape != None and self.inp_shape == bounds.shape:
   218                                                       r = self.constraints.lr
   219                                                       o = self.constraints.lo
   220                                                   else:
   221         2          3.0      1.5      0.0              self.inp_shape = bounds.shape
   222         2      84410.0  42205.0     61.8              r, o, out_shape = self.compute_weight_matrix(bounds.shape)
   223         2          9.0      4.5      0.0              self.constraints = DpConstraints(r, r, o, o)
   224         2          1.0      0.5      0.0              self.out_shape = out_shape
   225                                           
   226         2      52212.0  26106.0     38.2          self.bounds = bounds_mul_constraints(DpConstraints(r.t(), r.t(), o, o), bounds)
   227         2         30.0     15.0      0.0          self.bounds.lb = self.bounds.lb.view(self.out_shape)
   228         2          4.0      2.0      0.0          self.bounds.ub = self.bounds.ub.view(self.out_shape)
   229         2          0.0      0.0      0.0          return self.bounds

Total time: 2.62046 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: propagate_sample at line 284

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   284                                           @profile
   285                                           def propagate_sample(model, x, eps, le_layer=None, min_val=0, max_val=1, layers=None):
   286         1         57.0     57.0      0.0      bounds = get_input_bounds(x, eps, min_val, max_val)
   287         1          1.0      1.0      0.0      input_layer = DpInput(bounds)
   288         1          0.0      0.0      0.0      dp_layers = [input_layer] if layers == None else layers
   289         1        129.0    129.0      0.0      log_layer_bounds(logger, input_layer, 'Input Layer')
   290        11         12.0      1.1      0.0      for i, layer in enumerate(model):
   291        10          0.0      0.0      0.0          dp_layer = None
   292        10          3.0      0.3      0.0          if layers != None:
   293                                                       dp_layer = dp_layers[i + 1] # i + 1 as the first element is DpInput
   294                                                       dp_layer.compute_bound(dp_layers[i].bounds)
   295        10         13.0      1.3      0.0          elif isinstance(layer, nn.Flatten):
   296         1          2.0      2.0      0.0              dp_layer = DpFlatten(layer)
   297         1         38.0     38.0      0.0              dp_layer.compute_bound(dp_layers[i].bounds)
   298         9          4.0      0.4      0.0          elif isinstance(layer, nn.Linear):
   299         3         69.0     23.0      0.0              dp_layer = DpLinear(layer)
   300         3       1109.0    369.7      0.0              dp_layer.compute_bound(dp_layers[i].bounds)
   301         6          5.0      0.8      0.0          elif isinstance(layer, nn.ReLU):
   302         2          9.0      4.5      0.0              dp_layer = DpRelu(layer, False)
   303         2      97610.0  48805.0      3.7              dp_layer.compute_bound(dp_layers[i].bounds)
   304         4          1.0      0.2      0.0          elif isinstance(layer, nn.LeakyReLU):
   305         2          6.0      3.0      0.0              dp_layer = DpRelu(layer)
   306         2        515.0    257.5      0.0              dp_layer.compute_bound(dp_layers[i].bounds)
   307         2          0.0      0.0      0.0          elif isinstance(layer, nn.Conv2d):
   308         2          4.0      2.0      0.0              dp_layer = DpConv(layer)
   309         2     136697.0  68348.5      5.2              dp_layer.compute_bound(dp_layers[i].bounds)
   310                                           
   311                                                   #dp_layer.compute_bound(dp_layers[i].bounds)
   312        10          5.0      0.5      0.0          if layers == None:
   313        10         10.0      1.0      0.0              dp_layers.append(dp_layer)
   314                                                       
   315                                                   #TODO: Call backsub only before RELUs
   316        10         13.0      1.3      0.0          if not isinstance(layer, nn.Flatten):
   317         9    2353730.0 261525.6     89.8              dp_layer.bounds = deeppoly_backsub(dp_layers[:i+2]) # i + 2 as the first element is DpInput
   318                                           
   319        10       1034.0    103.4      0.0          log_layer_bounds(logger, dp_layer, f'Layer {i + 1} [{layer}]')
   320                                           
   321         1          0.0      0.0      0.0      if le_layer is not None:
   322         1          0.0      0.0      0.0          if layers is None:
   323         1          0.0      0.0      0.0              dp_layers.append(le_layer)
   324         1      29308.0  29308.0      1.1              le_layer.bounds = deeppoly_backsub(dp_layers)
   325                                                   else:
   326                                                       dp_layers[-1] = le_layer
   327                                                       le_layer.bounds = deeppoly_backsub(dp_layers)
   328         1         79.0     79.0      0.0          log_layer_bounds(logger, le_layer, f'Layer {len(dp_layers) - 1} [{le_layer}]:')
   329                                           
   330         1          0.0      0.0      0.0      return dp_layers

Total time: 2.62119 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: certify_sample at line 338

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   338                                           @profile
   339                                           def certify_sample(model, x, y, eps, use_le=True, use_slope_opt=True) -> bool:
   340         1        353.0    353.0      0.0      model.double()
   341         1          6.0      6.0      0.0      x.double()
   342                                           
   343         1          2.0      2.0      0.0      if x.dim() == 3:
   344         1          8.0      8.0      0.0          x = x.unsqueeze(0)
   345                                           
   346         1          1.0      1.0      0.0      if use_le:
   347         1         14.0     14.0      0.0          n_classes = model[-1].out_features
   348         1        211.0    211.0      0.0          le_layer = DiffLayer(y, n_classes)
   349         1    2620550.0    3e+06    100.0          dp_layers = propagate_sample(model, x, eps, le_layer=le_layer)
   350                                               else:
   351                                                   dp_layers = propagate_sample(model, x, eps)
   352                                           
   353         1          0.0      0.0      0.0      bounds = dp_layers[-1].bounds
   354                                           
   355         1         40.0     40.0      0.0      verified = check_postcondition_le(bounds) if use_le else check_postcondition(y, bounds)
   356         1          0.0      0.0      0.0      if verified:
   357                                                   logger.warning(f'Certification Distance: {bounds.get_certification_distance()}')
   358                                                   return True
   359                                               else:
   360         1          0.0      0.0      0.0          verified = certify_with_alphas(model, dp_layers, x, y, eps, use_le) if use_slope_opt else False
   361                                           
   362         1          0.0      0.0      0.0      return verified

Total time: 0 s
File: /Users/ariskoutris/Documents/Reliable and Trustworthy AI/Projects/rtai-project-28/code/deeppoly.py
Function: certify_with_alphas at line 364

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   364                                           @profile
   365                                           def certify_with_alphas(model, dp_layers, x, y, eps, use_le=True):
   366                                               
   367                                               alphas_dict = init_alphas(model, x.shape)
   368                                               if alphas_dict is None:
   369                                                   return False
   370                                               dp_layers = assign_alphas_to_relus(dp_layers, alphas_dict)
   371                                           
   372                                               loss_func = nn.CrossEntropyLoss() 
   373                                               optimizer = torch.optim.Adam([alphas_dict[key].value for key in alphas_dict], lr=2)
   374                                               
   375                                               #TODO: Add early stopping
   376                                               for _ in range(30):
   377                                                   
   378                                                   if use_le:
   379                                                       n_classes = model[-1].out_features
   380                                                       le_layer = DiffLayer(y, n_classes)
   381                                                       dp_layers = propagate_sample(model, x, eps, le_layer=le_layer, layers=dp_layers)
   382                                                   else:
   383                                                       dp_layers = propagate_sample(model, x, eps, layers=dp_layers)
   384                                                       
   385                                                   bounds = dp_layers[-1].bounds
   386                                                   
   387                                                   if use_le:
   388                                                       loss = torch.sum(-bounds.lb[bounds.lb < 0])
   389                                                   else:
   390                                                       loss = loss_func(bounds.get_loss_tensor(y), torch.tensor(y).view(1))
   391                                                   
   392                                                   optimizer.zero_grad()
   393                                                   loss.backward()
   394                                                   optimizer.step()
   395                                                   
   396                                                   for alpha_param in alphas_dict.values():
   397                                                       alpha_param.value.data.clamp_(alpha_param.lb, alpha_param.ub)
   398                                           
   399                                                   verified = check_postcondition_le(bounds) if use_le else check_postcondition(y, bounds)
   400                                                   if verified:
   401                                                       logger.warning(f'Certification Distance: {bounds.get_certification_distance()}\n')
   402                                                       return True
   403                                                   
   404                                               return False

